## Базова інформація
SLZB-OS - єдина операційна система для всіх пристроїв SLZB-06/06p7/06p10/06M та майбутніх пристроїв цієї лінійки.
<br>SLZB-OS використовує Berry Script Language [Official page](https://berry-lang.github.io/) Документація: [berry’s documentation](https://berry.readthedocs.io/en/latest/) and [Berry in 20 minutes or less](https://berry.readthedocs.io/en/latest/source/en/Berry-in-20-minutes.html)

## Особливості Berry на SLZB-OS
- Наразі ви можете мати до 3 запущених скриптів одночасно (може бути збільшено в майбутньому)
- Якщо скрипт не використовує події то кожен запущений скрипт працює в окремій задачі і має максимальний стек 5120 слів (може бути збільшено в майбутньому)
- Якщо скрипт використовує події то він запускається в задачі події (детільніше дивіться розділ "Події")
- Модуль ```SLZB``` завантажується автоматично для кожного скрипта але всі інші модулі мають бути підключені через ```import``` перед їх використанням
- Скрипт повинен містити метадату щоб система могляа його коректно завантажити. Прочитайте більше про це в секції "Метадата"

## Метадата
Метадата це системна інформація на основі якої SLZB-OS буде визначати як завантажувати скрипт. Та його додаткові параметри
<br>Матадата поділяється на обов'язкову і опціональну

### Обов'язкова метадата
```#META {"start":1}``` так виглядає базова обов'язкова метадата. Обов'язкова метадата завжди повинна вочинатись із коментаря ```#META ```(пробіл після #META обов'язковий!) та закінчуватись символом нового рядка (```\n```)
<br>Якщо скрипт не містить обов'язкової метадати то його не буде завантажено при старті системи але ви все ще можете запустити його в ручну.
<br>Параметер ```start``` визначає режим запуску скрипта. Підтримувані значення:
- 0 - скрипт запускається в ручному режимі
- 1 - скрипт запускається при старті системи (автоматично)

### Опціональна метадата
Наразі в розробці

## Система подій (доступно з v2.8.2.dev0)
Система подій дозволяє вам "підписатись" на певну подію в SLZB-OS і вказати функцію, що буде викликано при виникненні цієї події.
- Скрипт виконується в тій задачі, що викликала подію на яку він підписаний.
- Стан скрипта буде збережено між викликами події (всі глобальні змінні зберігають свій стан).
- Скрипт буде зупинено і підписки скасовано якщо під час виконання в скрипті виникне помилка.
- Скрипт, що викориистовує систему подій не повинен використовувати ```SLZB.delay()```.
- Скрипт не повинен виконуватись занадто дового.
- Ніяких вічних циклів в середині.
- Різні події можуть надавати додаткові дані при запуску скрипта, будь ласка, перевірте документацію на конктерну подію.
- Деякі події враховують, що ви повернете через ```return```,  будь ласка, перевірте документацію на конктерну подію.

Приклад: ви підписались на подію отримання нового пакету даних від зігбі чіпу: ```ZB.on_pkt(zb_pkt_handler)```
- читання і відправку даних до зігбі сокета буде призупинео доки не завершиться функція скрипта ```zb_pkt_handler()```
- якщо виконання буде занадто довгим це викличе втрату підключення до Z2M/ZHA тому вам не варто використовувати затримки тут.
- якщо ```zb_pkt_handler()``` поверне ```true``` то поточний пакет даних не буде відправлено до зігбі сокета.

Якщо скрипт підписаний на декілька подій то у випадку якщо вони виникнуть одночасно їх буде виконано по черзі з таймаутом 500мс.<br>
Це означає, що якщо виконання вашої функції в скрипті займе більше 500мс то ви можете пропустити одну з подій. Будь-ласка, перевірте блок-схему нижче:<br>
<img src="./images/be_events_ex.png?raw=true" width=650px/>

## API модулі SLZB-OS
### SLZB - загальні функції
```SLZB.delay(x)``` зупиняє виконання скрипта на X мілісекунд, максимальна затримка 4,294,967,295 мілісекунд або 1193 години. приймає один аргумент типу ```integer```
<br>Приклад: ```SLZB.delay(1000)``` зупинить виконання скрипту на 1 секунду.

```SLZB.millis()``` повертає кількість мілісекунд, що пройшло з моменту старту пристрою.
<br>Приклад: ```SLZB.log("device has been running for " .. SLZB.millis() / 1000 .. "seconds")``` виведе в консоь кількість секунд від старту пристрою.

```SLZB.reboot()``` перезавантажує пристрій.
<br>Приклад: ```SLZB.reboot()``` перезавантажить пристрій негайно!

```SLZB.log(x)``` відправляє текст в консоль відладки SLZB-06.
<br>Приклад: ```SLZB.log("Hello world!")``` виведе в консоль розробника текст ```Hello world!```

```SLZB.freeHeap()``` повертає загальну кількість вільної оперативної пам'яті у системі
<br>Приклад: ```SLZB.log("Free RAM: " .. SLZB.freeHeap())``` виведе в консоль кількість вільної RAM

(починаючи з v2.8.2.dev1)<br>
```SLZB.device_model()``` повертає модель пристрою (string)
<br>Приклад: ```SLZB.log("Device model: " .. SLZB.device_model())``` виведе в консоль модель пристрою (SLZB-06/SLZB-06P7/SLZB-06P10/SLZB-06M/SLZB-06Mg24)

### ZB - доступ до зігбі чіпу. Використовуйте з обережністю
#### Співіснування зігбі сокету та модуля zb
<img src="./images/zigbee access control.png?raw=true" width=650px/>
<br>SLZB-OS використовує паралельне виконання завдань. Це означає, що коли ви хочете отримати до зігбі чіпу ви маєте спочатку "заблокувати" право доступу за допомогою ```ZB.suspend()```
<br>Більшість функцій роблять це автоматично і вам не потрібно хвилюватись але є певний функціонал, що вимагає робити це в ручну.

#### Шо вимагає блокування доступу?
- ```ZB.readBytes()``` ви маєте заблокувати доступ через ```ZB.suspend()``` перед тим як читати байти від зігбі модуля. інакше задача обробки зігбі сокету, що виконується паралельно може забрати відповідь зігбі чіпу собі.

#### Співіснування із системою подій
Після виконання ```ZB.suspend(true)``` не будуть генеруватись події:
- ```ZB.on_pkt```
- ```ZB.on_disconnect```
- ```ZB.on_connect```


#### Доступні функції
```ZB.reboot()``` негайно перезавантажує зігбі чіп.
<br>Приклад: ```ZB.reboot()``` перезавантажить зігбі чіп.

```ZB.flashMode()``` переводить зігбі чіп в режим прошивки. Щоб перевести чіп в нормальний режим перезавантажте його або відправте відповідну команду бутлоадера.
<br>Приклад: ```ZB.flashMode()``` переводить зігбі чіп в режим прошивки.

```ZB.routerPairMode()``` запускає пошук мережі для спарювання якщо зігбі чіп прошито як роутер.
<br>Приклад: ```ZB.routerPairMode()``` запускає пошук мережі для спарювання якщо зігбі чіп прошито як роутер.

```zb.writeBytes(x)``` напряму відправляє до зігбі чіпу байти. Приймає один аргумент типу ```bytes``` і повертає ```integer``` з кількістю відправлених байт.
<br>Приклад: ```ZB.writeBytes(bytes("FE00210120"))``` відправляє до зігбі чіпу пінг-пакет.

```ZB.readBytes()``` читає байти від зігбі чіпу. повертає ```bytes```. Перед використанням цього зупиніть обробку зігбі сокету за допомогою ```ZB.suspend(true)``` інакше відповідь зігбі чіпу може забрати задача обробки сокету
<br>Приклад: ```ZB.readBytes()```.

```ZB.availableBytes()``` повертає кількість байт досупних до читання від зігбі чіпу. повертає ```integer```.
<br>Приклад: ```ZB.availableBytes()```.

```ZB.getZbClients()``` повертає кількість клієнтів підключених до зігбі сокету. повертає ```integer```.
<br>Приклад: ```ZB.getZbClients()```.

```ZB.suspend(x)``` зупиняє або відновлює обробку зігбі сокету. приймає один аргумент типу ```boolean```
<br>Приклад: ```ZB.suspend(true) SLZB.delay(5000) ZB.suspend(false)```. зупиняє обробку зігбі сокету на 5 секунд

#### Доступні події (доступно д v2.8.2.dev0)
```ZB.on_pkt(f)``` викликається при отриманні нового пакету даних від зігбі чіпу в режимі мережевого координатора. **Генерується тільки якщо увімкнено "Zigbee Socket packet processing" !!!**<br>
Приймає один аргумент типу ```function```.<br>
При виконанні надає 2 аргументи:
- id отриманого пакету, тип ```int```
- повний буффер пакету, тип ```bytes```

Якщо після виконання ви поврнете ```true``` то цей пакет даних не буде відправлено до зігбі сокету **(не працює для для EFR32x)**
<br>Приклад: перевірте [reports_stats.be](https://github.com/smlight-tech/slzb-os-scripts/blob/main/examlpes/cc2652x_reports_stats/reports_stats.be)

```ZB.on_connect(f)``` викликається при підключенні нового сокет-клієнту в режимі мережевого координатора.<br>
Приймає один аргумент типу ```function```.<br>
При виконанні надає 2 аргументи:
- IP новго клієнта, тип ```string```
- id новго клієнта (позиція в массиві клієнтів), тип ```int```

Якщо після виконання ви поврнете ```true``` то підключення від цього клієнту не буде прийнято.
<br>Приклад:
```berry
def conn_cb(ip, id)
  SLZB.log("ip: " .. ip .. " id: " .. id)
  return true
end
ZB.on_connect(conn_cb)
```

```ZB.on_disconnect(f)``` викликається при відключенні сокет-клієнту в режимі мережевого координатора.<br>
Приймає один аргумент типу ```function```.<br>
При виконанні надає 1 аргумент:
- id клієнта (позиція в массиві клієнтів), тип ```int```

<br>Приклад: перевірте [reports_stats.be](https://github.com/smlight-tech/slzb-os-scripts/blob/main/examlpes/cc2652x_reports_stats/reports_stats.be)

### FS - доступ до файлової системи. Використовуйте з обережністю
```FS.exists(x)``` перевіряє чи існує вказаний файл. Повертає ```boolean```
<br>Приклад: ```FS.exists("/be/test.be")```. Поверне ```true``` якщо скрипт ```/be/test.be``` існує

```FS.open(filename, mode)``` нативна функція для роботи з файлами. [Документація](https://berry.readthedocs.io/en/latest/source/en/Chapter-7.html?highlight=open#open-function)
<br>Приклад: перевірте приклад [get_file_size.be](https://github.com/smlight-tech/slzb-os-scripts/blob/main/examlpes/basic/get_file_size.be)

### WEBSERVER (доступно д v2.8.2.dev0) - дозволяє отримати або надати дані через POST/GET запити
Модуль вебсервера надає веб-хук за адресою ```<device ip>/script/webhook```
Ваш скрипт може отримати POST/GET параметри при виклику цього хука і також ви можете повернути будь-який текст у відповідь.
<br>Модуль дозволяє:
- Отримати кількість GET/POST параметрів
- Отримати значення GET/POST параметрів
- Надсилати будь-який тект у відповідь на запит

#### Доступні функції
```WEBSERVER.get_arg(x)``` повертає значення аргументу ```x```.<br>
Приймає на вхід ```int``` (для отримання аргументу по id) або ```string``` (для отримання аргументу по його назві).<br>
Повертає ```string```. Якщо аргумент не існує то поверне пустий рядок "".<br>

```WEBSERVER.has_arg(x)``` повертає ```true``` якщо аргумет ```x``` існує.<br>
Приймає на вхід ```string``` (назва аргументу).

```WEBSERVER.send(x, y, z)``` відправляє відповідь на запит клієнта. **БУДЬ ЛАСКА, ВИКОРИСТОВУЙТЕ ЦЕ ТІЛЬКИ В СЕРЕДИНІ ```WEBSERVER.on_webhook()```**<br>
Приймає на вхід:
- x - статус-код відповіді, тип ```int```
- y - тип контенту відповіді, тип ```string```
- z - текст відповіді, тип ```string```

Повертає: нічого.<br>
Приклад: перевірте [reports_stats.be](https://github.com/smlight-tech/slzb-os-scripts/blob/main/examlpes/cc2652x_reports_stats/reports_stats.be)

#### Доступні події
```WEBSERVER.on_webhook(f)``` - викликається коли виконується GET/POST запит на ```<device ip>/script/webhook```<br>
Приймає один аргумент типу ```function```.<br>
При виконанні надає 1 аргумент:
- кількість аргументів GET/POST запиту, тип ```int```

Приклад: перевірте [reports_stats.be](https://github.com/smlight-tech/slzb-os-scripts/blob/main/examlpes/cc2652x_reports_stats/reports_stats.be)